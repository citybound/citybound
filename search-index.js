var searchIndex = {};
searchIndex["chunky"] = {"doc":"This crate offers an abstraction over allocating fixed-size chunks of memory and different low-level collection types making use of these chunks to emulate \"infinite\" dynamically growing storages for heterogeneously-sized items.","items":[[3,"Ident","chunky","Identifies a chunk or chunk group uniquely - to be used for persistence",null,null],[12,"0","","",0,null],[3,"HeapHandler","","A `Handler` that allocates chunks on the heap",null,null],[3,"Value","","A single value stored in a chunk",null,null],[3,"ArenaIndex","","Refers to an item within an `Arena`",null,null],[12,"0","","",1,null],[3,"Arena","","Stores items of a fixed (max) size consecutively in a collection of chunks",null,null],[3,"Vector","","A vector which stores items of a known type in an `Arena`",null,null],[3,"Queue","","A FIFO queue which stores heterogeneously sized items",null,null],[3,"MultiArenaIndex","","Refers to an item in a `MultiArena`",null,null],[12,"0","","",2,null],[12,"1","","",2,null],[3,"MultiArena","","Based on a collection type for fixed-size items (\"Bin\"), creates a collection for heterogenously-sized items which will be stored in the most appropriately-sized bin.",null,null],[8,"Handler","","A strategy for managing chunks",null,null],[10,"create_chunk","","Create a new chunk with a given identifier, assumes it doesn't exist",3,null],[10,"load_or_create_chunk","","Load a chunk with a given identifier, or create it if it doesn't exist",3,null],[10,"load_chunk","","Load a chunk with a given identifier, assumes it exists",3,null],[10,"unload_chunk","","Deallocate a chunk, but keep any persisted representation of it",3,null],[10,"destroy_chunk","","Deallocate a chunk and delete any persisted representation of it",3,null],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"ident"}}],[11,"sub","","Create a sub-identifier within a group",0,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"ident"}}],[11,"from","","",0,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"create_chunk","","",4,null],[11,"load_or_create_chunk","","",4,null],[11,"load_chunk","","",4,null],[11,"unload_chunk","","",4,null],[11,"destroy_chunk","","",4,null],[11,"load_or_default","","Load the value in the chunk with the given identifier, or create it using a default value",5,{"i":[{"n":"ident"},{"n":"v"}],"o":{"n":"value"}}],[11,"deref","","",5,{"i":[{"n":"self"}],"o":{"n":"v"}}],[11,"deref_mut","","",5,{"i":[{"n":"self"}],"o":{"n":"v"}}],[11,"drop","","",5,{"i":[{"n":"self"}]}],[11,"clone","","",1,{"i":[{"n":"self"}],"o":{"n":"arenaindex"}}],[11,"new","","Create a new arena given a chunk group identifier, chunk size and (max) item size",6,{"i":[{"n":"ident"},{"n":"usize"},{"n":"usize"}],"o":{"n":"arena"}}],[11,"len","","Number of elements in the collection",6,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"is_empty","","Is the collection empty?",6,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"push","","Allocate space for a new item, returns a pointer to where the new item can be written to and the index that the new item will have.",6,null],[11,"pop_away","","Remove the last item from the end",6,{"i":[{"n":"self"}]}],[11,"swap_remove","","Remove the item at index, by swapping it with the last item and then popping, returning the swapped in item (unless empty).",6,{"i":[{"n":"self"},{"n":"arenaindex"}],"o":{"n":"option"}}],[11,"at","","Get a pointer to the item at `index`",6,null],[11,"at_mut","","Get a mutable pointer to the item at `index`",6,null],[11,"new","","Create a new chunky vector",7,{"i":[{"n":"ident"},{"n":"usize"}],"o":{"n":"self"}}],[11,"len","","Get the number of elements in the vector",7,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"is_empty","","Is the chunky vector empty?",7,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"at","","Get a reference to the item at `index`",7,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"option"}}],[11,"at_mut","","Get a mutable reference to the item at `index`",7,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"option"}}],[11,"push","","Push an item onto the vector",7,{"i":[{"n":"self"},{"n":"item"}]}],[11,"pop","","Remove and return the last item, if the vector wasn't empty",7,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"new","","Create a new queue",8,{"i":[{"n":"ident"},{"n":"usize"}],"o":{"n":"self"}}],[11,"len","","Number of items in the queue",8,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"is_empty","","Is the queue empty?",8,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"enqueue","","Enqueue an item of a given size. Returns a pointer that the item can be written to.",8,null],[11,"dequeue","","Dequeue an item. Returns a pointer to the item in the queue, unless the queue is empty.",8,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"drop_old_chunks","","Delete chunks which have already been read",8,{"i":[{"n":"self"}]}],[11,"clone","","",2,{"i":[{"n":"self"}],"o":{"n":"multiarenaindex"}}],[11,"new","","Create a new `MultiArena` collection using `Arena` bins and a base size that represents the smallest expected item size (used as the item size of the smallest-sized bin)",9,{"i":[{"n":"ident"},{"n":"usize"},{"n":"usize"}],"o":{"n":"self"}}],[11,"size_to_index","","Get the index of the Bin which stores items of size `size`",9,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"usize"}}],[11,"at","","Get an (untyped) pointer to the item at the given index",9,null],[11,"at_mut","","Get an (untyped) mutable pointer to the item at the given index",9,null],[11,"push","","Add an item to the end of the bin corresponding to its size",9,null],[11,"swap_remove_within_bin","","Remove the item referenced by `index` from its bin by swapping with the bin's last item",9,{"i":[{"n":"self"},{"n":"multiarenaindex"}],"o":{"n":"option"}}],[11,"populated_bin_indices_and_lens","","Return indices of bins that actually contain items and their respective lengths",9,null],[11,"bin_len","","Get the length of the bin of the given bin index",9,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"usize"}}]],"paths":[[3,"Ident"],[3,"ArenaIndex"],[3,"MultiArenaIndex"],[8,"Handler"],[3,"HeapHandler"],[3,"Value"],[3,"Arena"],[3,"Vector"],[3,"Queue"],[3,"MultiArena"]]};
searchIndex["compact"] = {"doc":"This crate makes it possible to store objects containing dynamic fields either compactly in consecutive memory or using traditional heap pointers.","items":[[3,"COption","compact","A wrapper to make an `Option` of a nontrivial `Compact` possible. Unfortunately, we can't blanket-`impl` that, since that overlaps (for the compiler) with the `impl` for trivial `Copy` types...",null,null],[12,"0","","",0,null],[3,"CVec","","A dynamically-sized vector that can be stored in compact sequential storage and automatically spills over into free heap storage using `Allocator`. Tries to closely follow the API of `std::vec::Vec`, but is not complete.",null,null],[3,"CString","","A compact storage for a `String`. So far doesn't support direct mutable operations, Only conversion from and to `String`/`&str`",null,null],[3,"CDict","","A simple linear-search key-value dictionary, implemented using two `CompactVec`'s, one for keys, one for values.",null,null],[3,"CHashMap","","A dynamically-sized open adressing quadratic probing hashmap that can be stored in compact sequential storage and automatically spills over into free heap storage using `Allocator`.",null,null],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"compactoption"}}],[11,"default","","",0,{"o":{"n":"compactoption"}}],[11,"deref","","",0,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"deref_mut","","",0,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"is_still_compact","","",0,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",0,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",0,null],[11,"decompact","","",0,null],[11,"len","","Get the number of elements in the vector",1,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"is_empty","","Is the vector empty?",1,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new","","Create a new, empty vector",1,{"o":{"n":"compactvec"}}],[11,"with_capacity","","Create a new, empty vector with a given capacity",1,{"i":[{"n":"usize"}],"o":{"n":"compactvec"}}],[11,"from_raw_parts","","Create a new vector from raw parts Assumes that `ptr` has been allocated by the same Allocator that is `A`",1,null],[11,"capacity","","current capacity",1,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"push","","Push an item onto the vector, spills onto the heap if the capacity in compact storage is insufficient",1,{"i":[{"n":"self"},{"n":"t"}]}],[11,"push_at","","push at position",1,{"i":[{"n":"self"},{"n":"usize"},{"n":"t"}]}],[11,"extend_from_copy_slice","","Extend from a copyable slice",1,null],[11,"pop","","Pop and return the last element, if the vector wasn't empty",1,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"insert","","Insert a value at `index`, copying the elements after `index` upwards",1,{"i":[{"n":"self"},{"n":"usize"},{"n":"t"}]}],[11,"remove","","Remove the element at `index`, copying the elements after `index` downwards",1,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"t"}}],[11,"retain","","Take a function which returns whether an element should be kept, and mutably removes all elements from the vector which are not kept",1,{"i":[{"n":"self"},{"n":"f"}]}],[11,"truncate","","Truncate the vector to the given length",1,{"i":[{"n":"self"},{"n":"usize"}]}],[11,"clear","","Clear the vector",1,{"i":[{"n":"self"}]}],[11,"drain","","Drain (empty & iterate over) the vector",1,{"i":[{"n":"self"}],"o":{"n":"intoiter"}}],[11,"ptr_to_string","","debug printing",1,{"i":[{"n":"self"}],"o":{"n":"string"}}],[11,"from","","Create a `CompactVec` from a normal `Vec`, directly using the backing storage as free heap storage",1,{"i":[{"n":"vec"}],"o":{"n":"self"}}],[11,"drop","","Drop elements and deallocate free heap storage, if any is allocated",1,{"i":[{"n":"self"}]}],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"into_iter","","",1,null],[11,"is_still_compact","","",1,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",1,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",1,null],[11,"decompact","","",1,null],[11,"is_still_compact","","",1,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",1,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",1,null],[11,"clone","","",1,{"i":[{"n":"self"}],"o":{"n":"compactvec"}}],[11,"clone","","",1,{"i":[{"n":"self"}],"o":{"n":"compactvec"}}],[11,"from_iter","","",1,{"i":[{"n":"i"}],"o":{"n":"self"}}],[11,"extend","","",1,{"i":[{"n":"self"},{"n":"i"}]}],[11,"default","","",1,{"o":{"n":"compactvec"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"serialize","","",1,{"i":[{"n":"self"},{"n":"s"}],"o":{"n":"result"}}],[11,"deserialize","","",1,{"i":[{"n":"d"}],"o":{"n":"result"}}],[11,"clone","","",2,{"i":[{"n":"self"}],"o":{"n":"compactstring"}}],[11,"default","","",2,{"o":{"n":"compactstring"}}],[11,"new","","Create an empty `CString`",2,{"o":{"n":"self"}}],[11,"push_str","","Appends a given string slice onto the end of this `CString`.",2,{"i":[{"n":"self"},{"n":"str"}]}],[11,"deref","","",2,{"i":[{"n":"self"}],"o":{"n":"str"}}],[11,"from","","",2,{"i":[{"n":"string"}],"o":{"n":"compactstring"}}],[11,"is_still_compact","","",2,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",2,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",2,null],[11,"decompact","","",2,null],[11,"new","","Create new, empty dictionary",3,{"o":{"n":"self"}}],[11,"len","","Amount of entries in the dictionary",3,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"is_empty","","Is the dictionary empty?",3,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"get","","Look up the value for key `query`, if it exists",3,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"option"}}],[11,"get_mut","","Look up the value for keu `query` mutably, if it exists",3,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"option"}}],[11,"get_mru","","Lookup up the value for key `query`, if it exists, but also swap the entry to the beginning of the key/value vectors, so a repeated lookup for that item will be faster",3,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"option"}}],[11,"get_mfu","","Lookup up the value for key `query`, if it exists, but also swap the entry one index towards the beginning of the key/value vectors, so frequently repeated lookups for that item will be faster",3,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"option"}}],[11,"contains_key","","Does the dictionary contain a value for `query`?",3,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"bool"}}],[11,"insert","","Insert new value at key `query` and return the previous value at that key, if any existed",3,{"i":[{"n":"self"},{"n":"k"},{"n":"v"}],"o":{"n":"option"}}],[11,"remove","","Remove value at key `query` and return it, if it existed",3,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"option"}}],[11,"keys","","Iterator over all keys in the dictionary",3,{"i":[{"n":"self"}],"o":{"n":"iter"}}],[11,"values","","Iterator over all values in the dictionary",3,{"i":[{"n":"self"}],"o":{"n":"iter"}}],[11,"values_mut","","Iterator over mutable references to all values in the dictionary",3,{"i":[{"n":"self"}],"o":{"n":"itermut"}}],[11,"pairs","","Iterator over all key-value pairs in the dictionary",3,null],[11,"push_at","","Push a value onto the `CompactVec` at the key `query`",3,{"i":[{"n":"self"},{"n":"k"},{"n":"i"}]}],[11,"get_iter","","Iterator over the `CompactVec` at the key `query`",3,null],[11,"remove_iter","","Remove the `CompactVec` at the key `query` and iterate over its elements (if it existed)",3,null],[11,"is_still_compact","","",3,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",3,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",3,null],[11,"decompact","","",3,null],[11,"clone","","",3,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"default","","",3,{"o":{"n":"self"}}],[11,"from_iter","","Construct a compact dictionary from an interator over key-value pairs",3,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"extend","","Extend a compact dictionary from an iterator over key-value pairs",3,{"i":[{"n":"self"},{"n":"t"}]}],[11,"new","","constructor",4,{"o":{"n":"self"}}],[11,"with_capacity","","constructor",4,{"i":[{"n":"usize"}],"o":{"n":"self"}}],[11,"len","","Amount of entries in the dictionary",4,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"is_empty","","Is the dictionary empty?",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"get","","Look up the value for key `query`, if it exists",4,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"option"}}],[11,"get_mut","","get mutable",4,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"option"}}],[11,"contains_key","","Does the dictionary contain a value for `query`?",4,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"bool"}}],[11,"insert","","Insert new value at key `query` and return the previous value at that key, if any existed",4,{"i":[{"n":"self"},{"n":"k"},{"n":"v"}],"o":{"n":"option"}}],[11,"remove","","Remove value at key `query` and return it, if it existed",4,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"option"}}],[11,"keys","","Iterator over all keys in the dictionary",4,null],[11,"values","","Iterator over all values in the dictionary",4,null],[11,"values_mut","","Iterator over mutable references to all values in the dictionary",4,null],[11,"pairs","","Iterator over all key-value pairs in the dictionary",4,null],[11,"pairs_mut","","Iterator over all key-value pairs in the dictionary, with the value as a mutable reference",4,null],[11,"is_still_compact","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",4,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",4,null],[11,"decompact","","",4,null],[11,"clone","","",4,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"default","","",4,{"o":{"n":"self"}}],[11,"from_iter","","Construct a compact dictionary from an interator over key-value pairs",4,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"push_at","","Push a value onto the `CompactVec` at the key `query`",4,{"i":[{"n":"self"},{"n":"k"},{"n":"i"}]}],[11,"get_iter","","Iterator over the `CompactVec` at the key `query`",4,null],[11,"remove_iter","","Remove the `CompactVec` at the key `query` and iterate over its elements (if it existed)",4,null],[11,"hash","","",1,{"i":[{"n":"self"},{"n":"h"}]}],[11,"serialize","","",4,{"i":[{"n":"self"},{"n":"s"}],"o":{"n":"result"}}],[11,"deserialize","","",4,{"i":[{"n":"d"}],"o":{"n":"result"}}],[8,"Compact","","A trait for objects with a statically-sized part and a potential dynamically-sized part that can be stored both compactly in consecutive memory or freely on the heap",null,null],[10,"is_still_compact","","Is the object's dynamic part stored compactly?",5,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[10,"dynamic_size_bytes","","Size of the dynamic part in bytes",5,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"total_size_bytes","","Total size of the object (static part + dynamic part)",5,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[10,"compact","","Copy the static part of `source` to `dest` and compactly store the dynamic part of `source` as the new dynamic part of `dest` at `new_dynamic_part`. This semantically moves source into dest.",5,null],[11,"behind","","Get a pointer to behind the static part of `self` (commonly used place for the dynamic part)",5,null],[11,"compact_behind","","Like `compact` with `new_dynamic_part` set to `dest.behind()`",5,null],[10,"decompact","","Creates a clone of self with the dynamic part guaranteed to be stored freely.",5,null],[11,"total_size_bytes","","Total size of the object (static part + dynamic part)",5,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"behind","","Get a pointer to behind the static part of `self` (commonly used place for the dynamic part)",5,null],[11,"compact_behind","","Like `compact` with `new_dynamic_part` set to `dest.behind()`",5,null]],"paths":[[3,"COption"],[3,"CVec"],[3,"CString"],[3,"CDict"],[3,"CHashMap"],[8,"Compact"]]};
searchIndex["compact_macros"] = {"doc":"Automatic `#[derive(Compact)]` macro for structs whose fields are all `Compact`","items":[[5,"derive_compact","compact_macros","",null,{"i":[{"n":"tokenstream"}],"o":{"n":"tokenstream"}}]],"paths":[]};
searchIndex["descartes"] = {"doc":"","items":[[5,"try_inverse","descartes","Tries to gets an inverted copy of a square matrix.",null,{"i":[{"n":"m"}],"o":{"n":"option"}}],[3,"BoundingBox","","",null,null],[12,"min","","",0,null],[12,"max","","",0,null],[3,"LineSegment","","",null,null],[12,"0","","",1,null],[12,"1","","",1,null],[3,"LinePath","","",null,null],[12,"points","","",2,null],[3,"ConcatError","","",null,null],[3,"ShiftVector","","",null,null],[12,"0","","",3,null],[3,"DashIterator","","",null,null],[3,"ClosedLinePath","","",null,null],[3,"CurvedPath","","",null,null],[3,"Intersection","","",null,null],[12,"along_a","","",4,null],[12,"along_b","","",4,null],[12,"position","","",4,null],[3,"UnclosedPathError","","",null,null],[3,"PrimitiveArea","","Represents a filled area bounded by a clockwise boundary. Everything \"right of\" the boundary is considered \"inside\"",null,null],[12,"boundary","","",5,null],[3,"Area","","",null,null],[12,"primitives","","",6,null],[3,"BoundaryPiece","","",null,null],[3,"AreaSplitResult","","",null,null],[3,"Band","","",null,null],[12,"path","","",7,null],[12,"width_left","","",7,null],[12,"width_right","","",7,null],[4,"CurvedSegment","","",null,null],[13,"Line","","",8,null],[13,"Arc","","",8,null],[4,"AreaLocation","","",null,null],[13,"Inside","","",9,null],[13,"Boundary","","",9,null],[13,"Outside","","",9,null],[4,"PieceEquivalence","","",null,null],[13,"Different","","",10,null],[13,"Forward","","",10,null],[13,"Backward","","",10,null],[4,"PieceRole","","",null,null],[13,"Forward","","",11,null],[13,"Backward","","",11,null],[13,"NonContributing","","",11,null],[4,"AreaError","","",null,null],[13,"WeldingShouldWork","","",12,null],[13,"LeftOver","","",12,null],[5,"angle_to","","",null,{"i":[{"n":"v2"},{"n":"v2"}],"o":{"n":"n"}}],[5,"angle_along_to","","",null,{"i":[{"n":"v2"},{"n":"v2"},{"n":"v2"}],"o":{"n":"n"}}],[5,"signed_angle_to","","",null,{"i":[{"n":"v2"},{"n":"v2"}],"o":{"n":"n"}}],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"boundingbox"}}],[11,"infinite","","",0,{"o":{"n":"self"}}],[11,"overlaps","","",0,{"i":[{"n":"self"},{"n":"boundingbox"}],"o":{"n":"bool"}}],[11,"point","","",0,{"i":[{"n":"p2"}],"o":{"n":"self"}}],[11,"grown_by","","",0,{"i":[{"n":"self"},{"n":"n"}],"o":{"n":"self"}}],[11,"clone","","",1,{"i":[{"n":"self"}],"o":{"n":"linesegment"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"start","","",1,{"i":[{"n":"self"}],"o":{"n":"p2"}}],[11,"end","","",1,{"i":[{"n":"self"}],"o":{"n":"p2"}}],[11,"length","","",1,{"i":[{"n":"self"}],"o":{"n":"n"}}],[11,"direction","","",1,{"i":[{"n":"self"}],"o":{"n":"v2"}}],[11,"along","","",1,{"i":[{"n":"self"},{"n":"n"}],"o":{"n":"p2"}}],[11,"midpoint","","",1,{"i":[{"n":"self"}],"o":{"n":"p2"}}],[11,"project_with_tolerance","","",1,{"i":[{"n":"self"},{"n":"p2"},{"n":"n"}],"o":{"n":"option"}}],[11,"project_with_max_distance","","",1,{"i":[{"n":"self"},{"n":"p2"},{"n":"n"},{"n":"n"}],"o":{"n":"option"}}],[11,"bounding_box","","",1,{"i":[{"n":"self"}],"o":{"n":"boundingbox"}}],[11,"is_still_compact","","",2,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",2,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",2,null],[11,"decompact","","",2,null],[11,"clone","","",2,{"i":[{"n":"self"}],"o":{"n":"linepath"}}],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","",2,{"i":[{"g":["p2"],"n":"veclike"}],"o":{"n":"option"}}],[11,"start","","",2,{"i":[{"n":"self"}],"o":{"n":"p2"}}],[11,"end","","",2,{"i":[{"n":"self"}],"o":{"n":"p2"}}],[11,"length","","",2,{"i":[{"n":"self"}],"o":{"n":"n"}}],[11,"segments","","",2,null],[11,"segments_with_distances","","",2,null],[11,"first_segment","","",2,{"i":[{"n":"self"}],"o":{"n":"linesegment"}}],[11,"last_segment","","",2,{"i":[{"n":"self"}],"o":{"n":"linesegment"}}],[11,"find_on_segment","","",2,{"i":[{"n":"self"},{"n":"n"}],"o":{"n":"option"}}],[11,"along","","",2,{"i":[{"n":"self"},{"n":"n"}],"o":{"n":"p2"}}],[11,"direction_along","","",2,{"i":[{"n":"self"},{"n":"n"}],"o":{"n":"v2"}}],[11,"start_direction","","",2,{"i":[{"n":"self"}],"o":{"n":"v2"}}],[11,"end_direction","","",2,{"i":[{"n":"self"}],"o":{"n":"v2"}}],[11,"project_with_tolerance","","",2,{"i":[{"n":"self"},{"n":"p2"},{"n":"n"}],"o":{"n":"option"}}],[11,"project_with_max_distance","","",2,{"i":[{"n":"self"},{"n":"p2"},{"n":"n"},{"n":"n"}],"o":{"n":"option"}}],[11,"project","","",2,{"i":[{"n":"self"},{"n":"p2"}],"o":{"n":"option"}}],[11,"includes","","",2,{"i":[{"n":"self"},{"n":"p2"}],"o":{"n":"bool"}}],[11,"distance_to","","",2,{"i":[{"n":"self"},{"n":"p2"}],"o":{"n":"n"}}],[11,"fmt","","",13,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"concat","","",2,{"i":[{"n":"self"},{"n":"self"}],"o":{"g":["concaterror"],"n":"result"}}],[11,"concat_weld","","",2,{"i":[{"n":"self"},{"n":"self"},{"n":"n"}],"o":{"g":["concaterror"],"n":"result"}}],[11,"reverse","","",2,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"subsection","","",2,{"i":[{"n":"self"},{"n":"n"},{"n":"n"}],"o":{"n":"option"}}],[11,"dash","","",2,{"i":[{"n":"self"},{"n":"n"},{"n":"n"}],"o":{"n":"dashiterator"}}],[11,"shift_orthogonally_vectors","","",2,null],[11,"shift_orthogonally","","",2,{"i":[{"n":"self"},{"n":"n"}],"o":{"n":"option"}}],[11,"with_new_start_and_end","","",2,{"i":[{"n":"self"},{"n":"p2"},{"n":"p2"}],"o":{"n":"option"}}],[11,"next","","",14,{"i":[{"n":"self"}],"o":{"g":["option"],"n":"option"}}],[11,"clone","","",15,{"i":[{"n":"self"}],"o":{"n":"closedlinepath"}}],[11,"fmt","","",15,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"is_still_compact","","",15,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",15,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",15,null],[11,"decompact","","",15,null],[11,"new","","",15,{"i":[{"n":"linepath"}],"o":{"n":"option"}}],[11,"try_clone_from","","",15,{"i":[{"n":"linepath"}],"o":{"n":"option"}}],[11,"path","","",15,{"i":[{"n":"self"}],"o":{"n":"linepath"}}],[11,"subsection","","",15,{"i":[{"n":"self"},{"n":"n"},{"n":"n"}],"o":{"g":["linepath"],"n":"option"}}],[11,"midpoint_between","","",15,{"i":[{"n":"self"},{"n":"n"},{"n":"n"}],"o":{"n":"p2"}}],[11,"clone","","",8,{"i":[{"n":"self"}],"o":{"n":"curvedsegment"}}],[11,"fmt","","",8,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"start","","",8,{"i":[{"n":"self"}],"o":{"n":"p2"}}],[11,"end","","",8,{"i":[{"n":"self"}],"o":{"n":"p2"}}],[11,"start_direction","","",8,{"i":[{"n":"self"}],"o":{"n":"v2"}}],[11,"end_direction","","",8,{"i":[{"n":"self"}],"o":{"n":"v2"}}],[11,"length","","",8,{"i":[{"n":"self"}],"o":{"n":"n"}}],[11,"is_still_compact","","",16,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",16,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",16,null],[11,"decompact","","",16,null],[11,"clone","","",16,{"i":[{"n":"self"}],"o":{"n":"curvedpath"}}],[11,"line","","",16,{"i":[{"n":"p2"},{"n":"p2"}],"o":{"n":"option"}}],[11,"arc","","",16,{"i":[{"n":"p2"},{"n":"v2"},{"n":"p2"}],"o":{"n":"option"}}],[11,"biarc","","",16,{"i":[{"n":"p2"},{"n":"v2"},{"n":"p2"},{"n":"v2"}],"o":{"n":"option"}}],[11,"circle","","",16,{"i":[{"n":"p2"},{"n":"n"}],"o":{"n":"option"}}],[11,"start","","",16,{"i":[{"n":"self"}],"o":{"n":"p2"}}],[11,"end","","",16,{"i":[{"n":"self"}],"o":{"n":"p2"}}],[11,"length","","",16,{"i":[{"n":"self"}],"o":{"n":"n"}}],[11,"start_direction","","",16,{"i":[{"n":"self"}],"o":{"n":"v2"}}],[11,"end_direction","","",16,{"i":[{"n":"self"}],"o":{"n":"v2"}}],[11,"segments","","",16,null],[11,"concat","","",16,{"i":[{"n":"self"},{"n":"self"}],"o":{"g":["concaterror"],"n":"result"}}],[11,"to_line_path_with_max_angle","","",16,{"i":[{"n":"self"},{"n":"n"}],"o":{"n":"linepath"}}],[11,"to_line_path","","",16,{"i":[{"n":"self"}],"o":{"n":"linepath"}}],[11,"clone","","",4,{"i":[{"n":"self"}],"o":{"n":"intersection"}}],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",4,{"i":[{"n":"self"},{"n":"intersection"}],"o":{"n":"bool"}}],[11,"ne","","",4,{"i":[{"n":"self"},{"n":"intersection"}],"o":{"n":"bool"}}],[11,"from_svg","","",2,{"i":[{"n":"str"}],"o":{"n":"option"}}],[11,"to_svg","","",2,{"i":[{"n":"self"}],"o":{"n":"string"}}],[11,"debug_svg","","",17,{"i":[{"n":"self"}],"o":{"n":"string"}}],[11,"fmt","","",18,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",9,{"i":[{"n":"self"},{"n":"arealocation"}],"o":{"n":"bool"}}],[11,"clone","","",5,{"i":[{"n":"self"}],"o":{"n":"primitivearea"}}],[11,"fmt","","",5,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"is_still_compact","","",5,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",5,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",5,null],[11,"decompact","","",5,null],[11,"new","","",5,{"i":[{"n":"closedlinepath"}],"o":{"n":"primitivearea"}}],[11,"fully_contains","","",5,{"i":[{"n":"self"},{"n":"primitivearea"}],"o":{"n":"bool"}}],[11,"winding_number","","",5,{"i":[{"n":"self"},{"n":"p2"}],"o":{"n":"f32"}}],[11,"location_of","","",5,{"i":[{"n":"self"},{"n":"p2"}],"o":{"n":"arealocation"}}],[11,"clone","","",6,{"i":[{"n":"self"}],"o":{"n":"area"}}],[11,"fmt","","",6,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"is_still_compact","","",6,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",6,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",6,null],[11,"decompact","","",6,null],[11,"new","","",6,{"i":[{"g":["primitivearea"],"n":"veclike"}],"o":{"n":"self"}}],[11,"new_simple","","",6,{"i":[{"n":"closedlinepath"}],"o":{"n":"self"}}],[11,"disjoint","","",6,{"i":[{"n":"self"}],"o":{"g":["area"],"n":"vec"}}],[11,"location_of","","",6,{"i":[{"n":"self"},{"n":"p2"}],"o":{"n":"arealocation"}}],[11,"eq","","",10,{"i":[{"n":"self"},{"n":"pieceequivalence"}],"o":{"n":"bool"}}],[11,"clone","","",10,{"i":[{"n":"self"}],"o":{"n":"pieceequivalence"}}],[11,"fmt","","",10,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"split","","",6,{"i":[{"n":"self"},{"n":"self"}],"o":{"n":"areasplitresult"}}],[11,"split_if_intersects","","",6,{"i":[{"n":"self"},{"n":"self"}],"o":{"g":["areasplitresult"],"n":"option"}}],[11,"fmt","","",12,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"get_area","","",17,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["area","areaerror"],"n":"result"}}],[11,"intersection","","",17,{"i":[{"n":"self"}],"o":{"g":["area","areaerror"],"n":"result"}}],[11,"union","","",17,{"i":[{"n":"self"}],"o":{"g":["area","areaerror"],"n":"result"}}],[11,"a_minus_b","","",17,{"i":[{"n":"self"}],"o":{"g":["area","areaerror"],"n":"result"}}],[11,"b_minus_a","","",17,{"i":[{"n":"self"}],"o":{"g":["area","areaerror"],"n":"result"}}],[11,"clone","","",7,{"i":[{"n":"self"}],"o":{"n":"band"}}],[11,"is_still_compact","","",7,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",7,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",7,null],[11,"decompact","","",7,null],[11,"new","","",7,{"i":[{"n":"linepath"},{"n":"n"}],"o":{"n":"band"}}],[11,"new_asymmetric","","",7,{"i":[{"n":"linepath"},{"n":"n"},{"n":"n"}],"o":{"n":"band"}}],[11,"outline","","",7,{"i":[{"n":"self"}],"o":{"n":"closedlinepath"}}],[11,"outline_distance_to_path_distance","","",7,{"i":[{"n":"self"},{"n":"n"}],"o":{"n":"n"}}],[11,"as_area","","",7,{"i":[{"n":"self"}],"o":{"n":"area"}}],[6,"VecLike","","",null,null],[6,"N","","",null,null],[6,"V2","","",null,null],[6,"P2","","",null,null],[6,"V3","","",null,null],[6,"V4","","",null,null],[6,"P3","","",null,null],[6,"M4","","",null,null],[6,"Iso3","","",null,null],[6,"Aff3","","",null,null],[6,"Persp3","","",null,null],[17,"THICKNESS","","",null,null],[8,"RoughEq","","",null,null],[11,"rough_eq","","",19,{"i":[{"n":"self"},{"n":"self"}],"o":{"n":"bool"}}],[10,"rough_eq_by","","",19,{"i":[{"n":"self"},{"n":"self"},{"n":"n"}],"o":{"n":"bool"}}],[8,"WithUniqueOrthogonal","","",null,null],[10,"orthogonal","","",20,{"i":[{"n":"self"}],"o":{"n":"self"}}],[8,"Into2d","","",null,null],[16,"Target","","",21,null],[10,"into_2d","","",21,null],[8,"Into3d","","",null,null],[16,"Target","","",22,null],[10,"into_3d","","",22,null],[8,"HasBoundingBox","","",null,null],[10,"bounding_box","","",23,{"i":[{"n":"self"}],"o":{"n":"boundingbox"}}],[8,"Intersect","","",null,null],[10,"intersect","","",24,{"i":[{"n":"self"}],"o":{"g":["intersection"],"n":"vec"}}],[8,"PointContainer","","",null,null],[10,"location_of","","",25,{"i":[{"n":"self"},{"n":"p2"}],"o":{"n":"arealocation"}}],[11,"contains","","",25,{"i":[{"n":"self"},{"n":"p2"}],"o":{"n":"bool"}}],[11,"rough_eq","","",19,{"i":[{"n":"self"},{"n":"self"}],"o":{"n":"bool"}}],[11,"rough_eq_by","","",26,{"i":[{"n":"self"},{"n":"n"},{"n":"n"}],"o":{"n":"bool"}}],[11,"rough_eq_by","","",27,{"i":[{"n":"self"},{"n":"p2"},{"n":"n"}],"o":{"n":"bool"}}],[11,"rough_eq_by","","",28,{"i":[{"n":"self"},{"n":"v2"},{"n":"n"}],"o":{"n":"bool"}}],[11,"orthogonal","","",28,{"i":[{"n":"self"}],"o":{"n":"v2"}}],[11,"into_2d","","",29,{"i":[{"n":"self"}],"o":{"n":"v2"}}],[11,"into_2d","","",30,{"i":[{"n":"self"}],"o":{"n":"p2"}}],[11,"into_3d","","",28,{"i":[{"n":"self"}],"o":{"n":"v3"}}],[11,"into_3d","","",27,{"i":[{"n":"self"}],"o":{"n":"p3"}}],[11,"contains","","",25,{"i":[{"n":"self"},{"n":"p2"}],"o":{"n":"bool"}}]],"paths":[[3,"BoundingBox"],[3,"LineSegment"],[3,"LinePath"],[3,"ShiftVector"],[3,"Intersection"],[3,"PrimitiveArea"],[3,"Area"],[3,"Band"],[4,"CurvedSegment"],[4,"AreaLocation"],[4,"PieceEquivalence"],[4,"PieceRole"],[4,"AreaError"],[3,"ConcatError"],[3,"DashIterator"],[3,"ClosedLinePath"],[3,"CurvedPath"],[3,"AreaSplitResult"],[3,"UnclosedPathError"],[8,"RoughEq"],[8,"WithUniqueOrthogonal"],[8,"Into2d"],[8,"Into3d"],[8,"HasBoundingBox"],[8,"Intersect"],[8,"PointContainer"],[6,"N"],[6,"P2"],[6,"V2"],[6,"V3"],[6,"P3"]]};
searchIndex["kay"] = {"doc":"`Kay` is a high-performance actor system, suitable for simulating millions of entities.","items":[[3,"ActorSystem","kay","The main thing inside of which all the magic happens.",null,null],[12,"panic_happened","","Flag that the system is in a panicked state",0,null],[12,"shutting_down","","Flag that the system is shutting down",0,null],[3,"World","","Gives limited access to an `ActorSystem` (typically from inside, in a message handler) to identify other actors and send messages to them.",null,null],[3,"External","","An owning reference to local state outside the actor system that can safely be embedded in actor states and passed in messages, as long as they stay on one machine.",null,null],[3,"MachineID","","Identifies a machine in the network",null,null],[12,"0","","",1,null],[3,"RawID","","A `RawID` uniquely identifies an `Actor`, or even a `Actor` within a `Swarm`",null,null],[12,"instance_id","","Used to identify instances within a top-level `Actor`. The main use-case is `Swarm` identifying and dispatching to its `Instances` using this field",2,null],[12,"type_id","","An ID for the type of the identified `Actor`, used to dispatch messages to the message handling functions registered for this type",2,null],[12,"machine","","ID of the machine (in a computing cluster or multiplayer environment) that the identified `Actor` lives on",2,null],[12,"version","","Allows safe reuse of a `RawID` after `Actor`/`Actor` death. The version is incremented to make the new (otherwise identical) `RawID` distinguishable from erroneous references to the `Actor`/`Actor` previously identified",2,null],[3,"Packet","","Combination of a message and its destination recipient id",null,null],[12,"recipient_id","","RawID of the `Actor`/`Actor` that should receive this message",3,null],[12,"message","","The message itself",3,null],[3,"Networking","","Represents all networking environment and networking state of an `ActorSystem`",null,null],[12,"machine_id","","The machine index of this machine within the network of peers",4,null],[12,"n_turns","","The current network turn this machine is in. Used to keep track if this machine lags behind or runs fast compared to its peers",4,null],[4,"Fate","","Return type of message handling functions, signifying if an `Actor`/`Actor` should live on after receiving a certain message type.",null,null],[13,"Live","","Means: the `Actor`/`Actor` should live on",5,null],[13,"Die","","Means: the `Actor`/`Actor` should be stopped, its state can be deallocated",5,null],[11,"new","","Create a new ActorSystem (usually only one per application is needed). Expects to get a panic callback as a parameter that is called when an actor panics during message handling and can thus be used to for example display the panic error message.",0,{"i":[{"n":"networking"}],"o":{"n":"actorsystem"}}],[11,"register","","Register a new Actor type with the system",0,{"i":[{"n":"self"}]}],[11,"add_handler","","Register a handler for an Actor type and Message type.",0,{"i":[{"n":"self"},{"n":"f"},{"n":"bool"}]}],[11,"add_spawner","","Register a handler that constructs an instance of an Actor type, given an RawID",0,{"i":[{"n":"self"},{"n":"f"},{"n":"bool"}]}],[11,"send","","Send a message to the actor(s) with a given `RawID`. This is only used to send messages into the system from outside. Inside actor message handlers you always have access to a `World` that allows you to send messages.",0,{"i":[{"n":"self"},{"n":"rawid"},{"n":"m"}]}],[11,"id","","Get the base RawID of an Actor type",0,{"i":[{"n":"self"}],"o":{"n":"rawid"}}],[11,"process_all_messages","","Processes all sent messages, and messages which are in turn sent during the handling of messages, up to a recursion depth of 1000.",0,{"i":[{"n":"self"}]}],[11,"world","","Get a world context directly from the system, typically to send messages from outside",0,{"i":[{"n":"self"}],"o":{"n":"world"}}],[11,"networking_connect","","Connect to all peers in the network",0,{"i":[{"n":"self"}]}],[11,"networking_send_and_receive","","Send queued outbound messages and take incoming queued messages and forward them to their local target recipient(s)",0,{"i":[{"n":"self"}]}],[11,"networking_finish_turn","","Finish the current networking turn and wait for peers which lag behind based on their turn number. This is the main backpressure mechanism.",0,{"i":[{"n":"self"}],"o":{"g":["usize"],"n":"option"}}],[11,"networking_machine_id","","The machine index of this machine within the network of peers",0,{"i":[{"n":"self"}],"o":{"n":"machineid"}}],[11,"networking_n_turns","","The current network turn this machine is in. Used to keep track if this machine lags behind or runs fast compared to its peers",0,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"networking_debug_all_n_turns","","Return a debug message containing the current local view of network turn progress of all peers in the network",0,{"i":[{"n":"self"}],"o":{"g":["machineid","isize"],"n":"hashmap"}}],[11,"get_instance_counts","","Get current instance counts for all actory types",0,{"i":[{"n":"self"}],"o":{"g":["string","usize"],"n":"hashmap"}}],[11,"get_message_statistics","","Get number of processed messages per message type since last reset",0,{"i":[{"n":"self"}],"o":{"g":["string","usize"],"n":"hashmap"}}],[11,"reset_message_statistics","","Reset count of processed messages",0,{"i":[{"n":"self"}]}],[11,"get_queue_lengths","","Get current inbox queue lengths per actor type",0,{"i":[{"n":"self"}],"o":{"g":["string","usize"],"n":"hashmap"}}],[11,"send","","Send a message to a (sub-)actor with the given RawID.",6,{"i":[{"n":"self"},{"n":"rawid"},{"n":"m"}]}],[11,"local_first","","Get the RawID of the first machine-local instance of an actor.",6,{"i":[{"n":"self"}],"o":{"n":"rawid"}}],[11,"global_first","","Get the RawID of the first instance of an actor on machine 0",6,{"i":[{"n":"self"}],"o":{"n":"rawid"}}],[11,"local_broadcast","","Get the RawID for a broadcast to all machine-local instances of an actor.",6,{"i":[{"n":"self"}],"o":{"n":"rawid"}}],[11,"global_broadcast","","Get the RawID for a global broadcast to all instances of an actor on all machines.",6,{"i":[{"n":"self"}],"o":{"n":"rawid"}}],[11,"allocate_instance_id","","Synchronously allocate a instance id for a instance that will later manually be added to a Swarm",6,{"i":[{"n":"self"}],"o":{"n":"rawid"}}],[11,"local_machine_id","","Get the id of the machine that we're currently in",6,{"i":[{"n":"self"}],"o":{"n":"machineid"}}],[11,"shutdown","","Signal intent to shutdown the actor system",6,{"i":[{"n":"self"}]}],[11,"new","","Allocate `content` on the heap and create a sharable `External` reference to it",7,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"from_box","","To interface with traditional owned boxes",7,{"i":[{"n":"box"}],"o":{"n":"self"}}],[11,"steal","","Like `clone`, just to make the danger more clear",7,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"into_box","","To interface with traditional owned boxes",7,{"i":[{"n":"self"}],"o":{"n":"box"}}],[11,"clone","","",7,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"deref","","",7,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"deref_mut","","",7,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"is_still_compact","","",7,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",7,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",7,null],[11,"decompact","","",7,null],[11,"clone","","",1,{"i":[{"n":"self"}],"o":{"n":"machineid"}}],[11,"eq","","",1,{"i":[{"n":"self"},{"n":"machineid"}],"o":{"n":"bool"}}],[11,"ne","","",1,{"i":[{"n":"self"},{"n":"machineid"}],"o":{"n":"bool"}}],[11,"partial_cmp","","",1,{"i":[{"n":"self"},{"n":"machineid"}],"o":{"g":["ordering"],"n":"option"}}],[11,"lt","","",1,{"i":[{"n":"self"},{"n":"machineid"}],"o":{"n":"bool"}}],[11,"le","","",1,{"i":[{"n":"self"},{"n":"machineid"}],"o":{"n":"bool"}}],[11,"gt","","",1,{"i":[{"n":"self"},{"n":"machineid"}],"o":{"n":"bool"}}],[11,"ge","","",1,{"i":[{"n":"self"},{"n":"machineid"}],"o":{"n":"bool"}}],[11,"cmp","","",1,{"i":[{"n":"self"},{"n":"machineid"}],"o":{"n":"ordering"}}],[11,"hash","","",1,null],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",2,{"i":[{"n":"self"}],"o":{"n":"rawid"}}],[11,"eq","","",2,{"i":[{"n":"self"},{"n":"rawid"}],"o":{"n":"bool"}}],[11,"ne","","",2,{"i":[{"n":"self"},{"n":"rawid"}],"o":{"n":"bool"}}],[11,"hash","","",2,null],[11,"new","","Create a new `RawID`",2,{"i":[{"n":"shorttypeid"},{"n":"u32"},{"n":"machineid"},{"n":"u8"}],"o":{"n":"self"}}],[11,"local_broadcast","","Get a version of an actor `RawID` that signals that a message should be delivered to all machine-local instances.",2,{"i":[{"n":"self"}],"o":{"n":"rawid"}}],[11,"global_broadcast","","Get a version of an actor `RawID` that signals that a message should be delivered globally (to all instances on all machines).",2,{"i":[{"n":"self"}],"o":{"n":"rawid"}}],[11,"is_broadcast","","Check whether this `RawID` signals a local or global broadcast.",2,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"is_global_broadcast","","Check whether this `RawID` signals specifically a global broadcast.",2,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"is_still_compact","","",3,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"dynamic_size_bytes","","",3,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"compact","","",3,null],[11,"decompact","","",3,null],[11,"clone","","",3,{"i":[{"n":"self"}],"o":{"n":"packet"}}],[11,"new","","Create network environment based on this machines id/index and all peer addresses (including this machine)",4,{"i":[{"n":"u8"},{"g":["str"],"n":"vec"},{"n":"usize"},{"n":"usize"},{"n":"usize"}],"o":{"n":"networking"}}],[11,"connect","","Try to connect to peers in the network",4,{"i":[{"n":"self"}]}],[11,"finish_turn","","Finish the current networking turn and wait for peers which lag behind based on their turn number. This is the main backpressure mechanism.",4,{"i":[{"n":"self"}],"o":{"g":["usize"],"n":"option"}}],[11,"send_and_receive","","Send queued outbound messages and take incoming queued messages and forward them to their local target recipient(s)",4,null],[11,"enqueue","","Enqueue a new (potentially) outbound packet",4,{"i":[{"n":"self"},{"n":"shorttypeid"},{"n":"packet"}]}],[11,"debug_all_n_turns","","Return a debug message containing the current local view of network turn progress of all peers in the network",4,{"i":[{"n":"self"}],"o":{"g":["machineid","isize"],"n":"hashmap"}}],[8,"Actor","","Trait that Actors instance have to implement for a `Swarm` so their internally stored instance `RawID` can be gotten and set.",null,null],[16,"ID","","The unique `TypedID` of this actor",8,null],[10,"id","","Get `TypedID` of this actor",8,null],[10,"set_id","","Set the full RawID (Actor type id + instance id) of this actor (only used internally by `Swarm`)",8,{"i":[{"n":"self"},{"n":"rawid"}]}],[11,"id_as","","Get the id of this actor as an actor trait `TypedID` (available if the actor implements the corresponding trait)",8,{"i":[{"n":"self"}],"o":{"n":"targetid"}}],[11,"local_first","","Get the `TypedID` of the local first actor of this kind",8,null],[11,"global_first","","Get the `TypedID` of the global first actor of this kind",8,null],[11,"local_broadcast","","Get the `TypedID` representing a local broadcast to actors of this type",8,null],[11,"global_broadcast","","Get the `TypedID` representing a global broadcast to actors of this type",8,null],[8,"TraitIDFrom","","Helper trait that signifies that an actor's `TypedID` can be converted to an actor trait `TypedID` if that actor implements the corresponding trait.",null,null],[11,"from","","Construct the actor trait `TypedID` from an actor's `TypedID`",9,null],[8,"TypedID","","`TypedID` is a construct on top of a `RawID` that can refer to a specific kind of actor, or actor trait at compile time",null,null],[10,"as_raw","","Get the underlying `RawID`",10,{"i":[{"n":"self"}],"o":{"n":"rawid"}}],[10,"from_raw","","Construct a new `TypedID` from a `RawID` - this implies knowledge about the type of actor referenced by the `RawID`",10,{"i":[{"n":"rawid"}],"o":{"n":"self"}}],[8,"Message","","Trait that a datastructure must implement in order to be sent and received as a message.",null,null],[11,"id_as","","Get the id of this actor as an actor trait `TypedID` (available if the actor implements the corresponding trait)",8,{"i":[{"n":"self"}],"o":{"n":"targetid"}}],[11,"local_first","","Get the `TypedID` of the local first actor of this kind",8,null],[11,"global_first","","Get the `TypedID` of the global first actor of this kind",8,null],[11,"local_broadcast","","Get the `TypedID` representing a local broadcast to actors of this type",8,null],[11,"global_broadcast","","Get the `TypedID` representing a global broadcast to actors of this type",8,null],[11,"from","","Construct the actor trait `TypedID` from an actor's `TypedID`",9,null]],"paths":[[3,"ActorSystem"],[3,"MachineID"],[3,"RawID"],[3,"Packet"],[3,"Networking"],[4,"Fate"],[3,"World"],[3,"External"],[8,"Actor"],[8,"TraitIDFrom"],[8,"TypedID"]]};
searchIndex["kay_codegen"] = {"doc":"","items":[[3,"Model","kay_codegen","",null,null],[12,"actors","","",0,null],[12,"traits","","",0,null],[3,"ActorDef","","",null,null],[12,"handlers","","",1,null],[12,"impls","","",1,null],[12,"defined_here","","",1,null],[3,"TraitDef","","",null,null],[12,"handlers","","",2,null],[3,"Handler","","",null,null],[4,"HandlerType","","",null,null],[13,"Handler","","",3,null],[13,"Init","","",3,null],[5,"scan_and_generate","","",null,{"i":[{"n":"str"}]}],[5,"generate","","",null,{"i":[{"n":"model"}],"o":{"n":"string"}}],[11,"map_handlers","","",1,{"i":[{"n":"self"},{"n":"ty"},{"n":"handlerorigin"},{"n":"handlertype"},{"n":"f"}],"o":{"n":"vec"}}],[11,"map_handlers","","",2,{"i":[{"n":"self"},{"n":"path"},{"n":"handlertype"},{"n":"f"}],"o":{"n":"vec"}}],[11,"map_handlers","","",0,null],[11,"map_handlers_args","","",0,null],[11,"map_trait_handlers","","",0,null],[11,"map_trait_handlers_args","","",0,null],[11,"generate_setups","","",0,{"i":[{"n":"self"}],"o":{"n":"tokens"}}],[11,"generate_traits","","",0,{"i":[{"n":"self"}],"o":{"n":"tokens"}}],[11,"generate_actor_ids_messages_and_conversions","","",0,{"i":[{"n":"self"}],"o":{"n":"tokens"}}],[11,"default","","",0,{"o":{"n":"model"}}],[11,"default","","",1,{"o":{"n":"actordef"}}],[11,"default","","",2,{"o":{"n":"traitdef"}}],[11,"clone","","",4,{"i":[{"n":"self"}],"o":{"n":"handler"}}],[11,"clone","","",3,{"i":[{"n":"self"}],"o":{"n":"handlertype"}}],[11,"eq","","",3,{"i":[{"n":"self"},{"n":"handlertype"}],"o":{"n":"bool"}}]],"paths":[[3,"Model"],[3,"ActorDef"],[3,"TraitDef"],[4,"HandlerType"],[3,"Handler"]]};
initSearch(searchIndex);
