<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `CString` struct in crate `compact`."><meta name="keywords" content="rust, rustlang, rust-lang, CString"><title>compact::CString - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Struct CString</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.new">new</a><a href="#method.push_str">push_str</a></div><a class="sidebar-title" href="#deref-methods">Methods from Deref&lt;Target=str&gt;</a><div class="sidebar-links"><a href="#method.len">len</a><a href="#method.is_empty">is_empty</a><a href="#method.is_char_boundary">is_char_boundary</a><a href="#method.as_bytes">as_bytes</a><a href="#method.as_ptr">as_ptr</a><a href="#method.get">get</a><a href="#method.get_unchecked">get_unchecked</a><a href="#method.slice_unchecked">slice_unchecked</a><a href="#method.split_at">split_at</a><a href="#method.chars">chars</a><a href="#method.char_indices">char_indices</a><a href="#method.bytes">bytes</a><a href="#method.split_whitespace">split_whitespace</a><a href="#method.lines">lines</a><a href="#method.lines_any">lines_any</a><a href="#method.encode_utf16">encode_utf16</a><a href="#method.contains">contains</a><a href="#method.starts_with">starts_with</a><a href="#method.ends_with">ends_with</a><a href="#method.find">find</a><a href="#method.rfind">rfind</a><a href="#method.split">split</a><a href="#method.rsplit">rsplit</a><a href="#method.split_terminator">split_terminator</a><a href="#method.rsplit_terminator">rsplit_terminator</a><a href="#method.splitn">splitn</a><a href="#method.rsplitn">rsplitn</a><a href="#method.matches">matches</a><a href="#method.rmatches">rmatches</a><a href="#method.match_indices">match_indices</a><a href="#method.rmatch_indices">rmatch_indices</a><a href="#method.trim">trim</a><a href="#method.trim_left">trim_left</a><a href="#method.trim_right">trim_right</a><a href="#method.trim_matches">trim_matches</a><a href="#method.trim_left_matches">trim_left_matches</a><a href="#method.trim_right_matches">trim_right_matches</a><a href="#method.parse">parse</a><a href="#method.is_ascii">is_ascii</a><a href="#method.eq_ignore_ascii_case">eq_ignore_ascii_case</a><a href="#method.replace">replace</a><a href="#method.replacen">replacen</a><a href="#method.to_lowercase">to_lowercase</a><a href="#method.to_uppercase">to_uppercase</a><a href="#method.escape_debug">escape_debug</a><a href="#method.escape_default">escape_default</a><a href="#method.escape_unicode">escape_unicode</a><a href="#method.repeat">repeat</a><a href="#method.to_ascii_uppercase">to_ascii_uppercase</a><a href="#method.to_ascii_lowercase">to_ascii_lowercase</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-Default">Default</a><a href="#impl-Deref">Deref</a><a href="#impl-From%3CString%3E">From&lt;String&gt;</a><a href="#impl-Compact">Compact</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a></div></div><p class='location'><a href='index.html'>compact</a></p><script>window.sidebarCurrent = {name: 'CString', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>compact</a>::<wbr><a class="struct" href=''>CString</a></span><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/compact/compact_str.rs.html#7-9' title='goto source code'>[src]</a></span></h1><div class="docblock type-decl"><pre class='rust struct'>pub struct CString { /* fields omitted */ }</pre></div><div class='docblock'><p>A compact storage for a <code>String</code>. So far doesn't support direct mutable operations,
Only conversion from and to <code>String</code>/<code>&amp;str</code></p>
</div>
                    <h2 id='methods' class='small-section-header'>
                      Methods<a href='#methods' class='anchor'></a>
                    </h2>
                <h3 id='impl' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="struct" href="../compact/struct.CString.html" title="struct compact::CString">CompactString</a></code><a href='#impl' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#11-21' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.new' class="method"><span id='new.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.new' class='fnname'>new</a>() -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#13-15' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Create an empty <code>CString</code></p>
</div><h4 id='method.push_str' class="method"><span id='push_str.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.push_str' class='fnname'>push_str</a>(&amp;mut self, string: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>)</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#18-20' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Appends a given string slice onto the end of this <code>CString</code>.</p>
</div></div>
                    <h2 id='deref-methods' class='small-section-header'>
                      Methods from <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;<a href='#deref-methods' class='anchor'></a>
                    </h2>
                <div class='impl-items'><h4 id='method.len' class="method"><span id='len.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub const fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2139-2141' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the length of <code>self</code>.</p>
<p>This length is in bytes, not <a href="primitive.char.html"><code>char</code></a>s or graphemes. In other words,
it may not be what a human considers the length of the string.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="string">&quot;foo&quot;</span>.<span class="ident">len</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">3</span>, <span class="ident">len</span>);

<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="string">&quot;∆íoo&quot;</span>.<span class="ident">len</span>(); <span class="comment">// fancy f!</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">4</span>, <span class="ident">len</span>);</pre>
</div><h4 id='method.is_empty' class="method"><span id='is_empty.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub const fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2159-2161' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">is_empty</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;not empty&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_empty</span>());</pre>
</div><h4 id='method.is_char_boundary' class="method"><span id='is_char_boundary.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.is_char_boundary' class='fnname'>is_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.9.0'>1.9.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2189-2199' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Checks that <code>index</code>-th byte lies at the start and/or end of a
UTF-8 code point sequence.</p>
<p>The start and end of the string (when <code>index == self.len()</code>) are
considered to be
boundaries.</p>
<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;L√∂we ËÄÅËôé L√©opard&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">0</span>));
<span class="comment">// start of `ËÄÅ`</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">6</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="ident">s</span>.<span class="ident">len</span>()));

<span class="comment">// second byte of `√∂`</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">2</span>));

<span class="comment">// third byte of `ËÄÅ`</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">8</span>));</pre>
</div><h4 id='method.as_bytes' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span></div><div class="content hidden"><h3 class="important">Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span></code></div></div><span id='as_bytes.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub const fn <a href='#method.as_bytes' class='fnname'>as_bytes</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2217-2223' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Converts a string slice to a byte slice. To convert the byte slice back
into a string slice, use the <a href="./str/fn.from_utf8.html"><code>str::from_utf8</code></a> function.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">&quot;bors&quot;</span>.<span class="ident">as_bytes</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;bors&quot;</span>, <span class="ident">bytes</span>);</pre>
</div><h4 id='method.as_ptr' class="method"><span id='as_ptr.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub const fn <a href='#method.as_ptr' class='fnname'>as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2283-2285' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Converts a string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="primitive.u8.html"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Hello&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();</pre>
</div><h4 id='method.get' class="method"><span id='get.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.get' class='fnname'>get</a>&lt;I&gt;(&amp;self, i: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;&lt;I as <a class="trait" href="https://doc.rust-lang.org/nightly/core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.20.0'>1.20.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2310-2312' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="option/enum.Option.html#variant.None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;üóª‚ààüåè&quot;</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;üóª&quot;</span>), <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">0</span>..<span class="number">4</span>));

<span class="comment">// indices not on UTF-8 sequence boundaries</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">get</span>(<span class="number">1</span>..).<span class="ident">is_none</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">get</span>(..<span class="number">8</span>).<span class="ident">is_none</span>());

<span class="comment">// out of bounds</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">get</span>(..<span class="number">42</span>).<span class="ident">is_none</span>());</pre>
</div><h4 id='method.get_unchecked' class="method"><span id='get_unchecked.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.get_unchecked' class='fnname'>get_unchecked</a>&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as <a class="trait" href="https://doc.rust-lang.org/nightly/core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.20.0'>1.20.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2376-2378' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must come before the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="string">&quot;üóª‚ààüåè&quot;</span>;
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;üóª&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;‚àà&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;üåè&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">7</span>..<span class="number">11</span>));
}</pre>
</div><h4 id='method.slice_unchecked' class="method"><span id='slice_unchecked.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub unsafe fn <a href='#method.slice_unchecked' class='fnname'>slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, end: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2457-2459' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Creates a string slice from another string slice, bypassing safety
checks.</p>
<p>This is generally not recommended, use with caution! For a safe
alternative see <a href="primitive.str.html"><code>str</code></a> and <a href="ops/trait.Index.html"><code>Index</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get a mutable string slice instead, see the
<a href="#method.slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must come before <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;L√∂we ËÄÅËôé L√©opard&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;L√∂we ËÄÅËôé L√©opard&quot;</span>, <span class="ident">s</span>.<span class="ident">slice_unchecked</span>(<span class="number">0</span>, <span class="number">21</span>));
}

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Hello, world!&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;world&quot;</span>, <span class="ident">s</span>.<span class="ident">slice_unchecked</span>(<span class="number">7</span>, <span class="number">12</span>));
}</pre>
</div><h4 id='method.split_at' class="method"><span id='split_at.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.split_at' class='fnname'>split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a>&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.4.0'>1.4.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2523-2533' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Divide one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="#method.split_at_mut"><code>split_at_mut</code></a>
method.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is
beyond the last code point of the string slice.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Per Martin-L√∂f&quot;</span>;

<span class="kw">let</span> (<span class="ident">first</span>, <span class="ident">last</span>) <span class="op">=</span> <span class="ident">s</span>.<span class="ident">split_at</span>(<span class="number">3</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Per&quot;</span>, <span class="ident">first</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot; Martin-L√∂f&quot;</span>, <span class="ident">last</span>);</pre>
</div><h4 id='method.chars' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Chars.html" title="struct core::str::Chars">Chars</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Chars.html" title="struct core::str::Chars">Chars</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Chars.html" title="struct core::str::Chars">Chars</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>;</span></code></div></div><span id='chars.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.chars' class='fnname'>chars</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Chars.html" title="struct core::str::Chars">Chars</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2633-2635' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns an iterator over the <a href="primitive.char.html"><code>char</code></a>s of a string slice.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="primitive.char.html"><code>char</code></a>. This method returns such an iterator.</p>
<p>It's important to remember that <a href="primitive.char.html"><code>char</code></a> represents a Unicode Scalar
Value, and may not match your idea of what a 'character' is. Iteration
over grapheme clusters may be what you actually want.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">word</span> <span class="op">=</span> <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">chars</span>().<span class="ident">count</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">7</span>, <span class="ident">count</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chars</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">chars</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;g&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;d&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;b&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;e&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">chars</span>.<span class="ident">next</span>());</pre>
<p>Remember, <a href="primitive.char.html"><code>char</code></a>s may not match your human intuition about characters:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="string">&quot;yÃÜ&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chars</span> <span class="op">=</span> <span class="ident">y</span>.<span class="ident">chars</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>()); <span class="comment">// not &#39;yÃÜ&#39;</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;\u{0306}&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">chars</span>.<span class="ident">next</span>());</pre>
</div><h4 id='method.char_indices' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.CharIndices.html" title="struct core::str::CharIndices">CharIndices</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.CharIndices.html" title="struct core::str::CharIndices">CharIndices</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.CharIndices.html" title="struct core::str::CharIndices">CharIndices</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><span id='char_indices.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.char_indices' class='fnname'>char_indices</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.CharIndices.html" title="struct core::str::CharIndices">CharIndices</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2690-2692' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns an iterator over the <a href="primitive.char.html"><code>char</code></a>s of a string slice, and their
positions.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="primitive.char.html"><code>char</code></a>. This method returns an iterator of both
these <a href="primitive.char.html"><code>char</code></a>s, as well as their byte positions.</p>
<p>The iterator yields tuples. The position is first, the <a href="primitive.char.html"><code>char</code></a> is
second.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">word</span> <span class="op">=</span> <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">char_indices</span>().<span class="ident">count</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">7</span>, <span class="ident">count</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">char_indices</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">char_indices</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;g&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;o&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">&#39;o&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;d&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;b&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">5</span>, <span class="string">&#39;y&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">6</span>, <span class="string">&#39;e&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">char_indices</span>.<span class="ident">next</span>());</pre>
<p>Remember, <a href="primitive.char.html"><code>char</code></a>s may not match your human intuition about characters:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">yes</span> <span class="op">=</span> <span class="string">&quot;yÃÜes&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">char_indices</span> <span class="op">=</span> <span class="ident">yes</span>.<span class="ident">char_indices</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;y&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>()); <span class="comment">// not (0, &#39;yÃÜ&#39;)</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;\u{0306}&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="comment">// note the 3 here - the last character took up two bytes</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;e&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;s&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">char_indices</span>.<span class="ident">next</span>());</pre>
</div><h4 id='method.bytes' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Bytes.html" title="struct core::str::Bytes">Bytes</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Bytes.html" title="struct core::str::Bytes">Bytes</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Bytes.html" title="struct core::str::Bytes">Bytes</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>;</span></code></div></div><span id='bytes.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.bytes' class='fnname'>bytes</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Bytes.html" title="struct core::str::Bytes">Bytes</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2715-2717' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>An iterator over the bytes of a string slice.</p>
<p>As a string slice consists of a sequence of bytes, we can iterate
through a string slice by byte. This method returns such an iterator.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">&quot;bors&quot;</span>.<span class="ident">bytes</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;b&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;o&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;r&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;s&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">bytes</span>.<span class="ident">next</span>());</pre>
</div><h4 id='method.split_whitespace' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitWhitespace.html" title="struct core::str::SplitWhitespace">SplitWhitespace</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitWhitespace.html" title="struct core::str::SplitWhitespace">SplitWhitespace</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitWhitespace.html" title="struct core::str::SplitWhitespace">SplitWhitespace</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><span id='split_whitespace.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.split_whitespace' class='fnname'>split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitWhitespace.html" title="struct core::str::SplitWhitespace">SplitWhitespace</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.1.0'>1.1.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2755-2757' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Split a string slice by whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of whitespace.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot;A few words&quot;</span>.<span class="ident">split_whitespace</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;A&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;few&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;words&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</pre>
<p>All kinds of whitespace are considered:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot; Mary   had\ta\u{2009}little  \n\t lamb&quot;</span>.<span class="ident">split_whitespace</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Mary&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;had&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;little&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;lamb&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</pre>
</div><h4 id='method.lines' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Lines.html" title="struct core::str::Lines">Lines</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Lines.html" title="struct core::str::Lines">Lines</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Lines.html" title="struct core::str::Lines">Lines</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><span id='lines.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.lines' class='fnname'>lines</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Lines.html" title="struct core::str::Lines">Lines</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2797-2799' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>An iterator over the lines of a string, as string slices.</p>
<p>Lines are ended with either a newline (<code>\n</code>) or a carriage return with
a line feed (<code>\r\n</code>).</p>
<p>The final line ending is optional.</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;foo\r\nbar\n\nbaz\n&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lines</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">lines</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">lines</span>.<span class="ident">next</span>());</pre>
<p>The final line ending isn't required:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;foo\nbar\n\r\nbaz&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lines</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">lines</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">lines</span>.<span class="ident">next</span>());</pre>
</div><h4 id='method.lines_any' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.LinesAny.html" title="struct core::str::LinesAny">LinesAny</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.LinesAny.html" title="struct core::str::LinesAny">LinesAny</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.LinesAny.html" title="struct core::str::LinesAny">LinesAny</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><span id='lines_any.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.lines_any' class='fnname'>lines_any</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.LinesAny.html" title="struct core::str::LinesAny">LinesAny</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2806-2808' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='stability'><div class='stab deprecated'>Deprecated since 1.4.0<p>: use lines() instead now</p>
</div></div><div class='docblock'><p>An iterator over the lines of a string.</p>
</div><h4 id='method.encode_utf16' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.EncodeUtf16.html" title="struct core::str::EncodeUtf16">EncodeUtf16</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.EncodeUtf16.html" title="struct core::str::EncodeUtf16">EncodeUtf16</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.EncodeUtf16.html" title="struct core::str::EncodeUtf16">EncodeUtf16</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a>;</span></code></div></div><span id='encode_utf16.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.encode_utf16' class='fnname'>encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.EncodeUtf16.html" title="struct core::str::EncodeUtf16">EncodeUtf16</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.8.0'>1.8.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2825-2827' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;Za≈º√≥≈Çƒá gƒô≈õlƒÖ ja≈∫≈Ñ&quot;</span>;

<span class="kw">let</span> <span class="ident">utf8_len</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">len</span>();
<span class="kw">let</span> <span class="ident">utf16_len</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">encode_utf16</span>().<span class="ident">count</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">utf16_len</span> <span class="op">&lt;=</span> <span class="ident">utf8_len</span>);</pre>
</div><h4 id='method.contains' class="method"><span id='contains.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.contains' class='fnname'>contains</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2846-2848' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns <code>true</code> if the given pattern matches a sub-slice of
this string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bananas</span>.<span class="ident">contains</span>(<span class="string">&quot;nana&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">contains</span>(<span class="string">&quot;apples&quot;</span>));</pre>
</div><h4 id='method.starts_with' class="method"><span id='starts_with.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.starts_with' class='fnname'>starts_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2866-2868' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns <code>true</code> if the given pattern matches a prefix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bananas</span>.<span class="ident">starts_with</span>(<span class="string">&quot;bana&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">starts_with</span>(<span class="string">&quot;nana&quot;</span>));</pre>
</div><h4 id='method.ends_with' class="method"><span id='ends_with.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.ends_with' class='fnname'>ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2886-2890' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns <code>true</code> if the given pattern matches a suffix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bananas</span>.<span class="ident">ends_with</span>(<span class="string">&quot;anas&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">ends_with</span>(<span class="string">&quot;nana&quot;</span>));</pre>
</div><h4 id='method.find' class="method"><span id='find.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.find' class='fnname'>find</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2936-2938' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the byte index of the first character of this string slice that
matches the pattern.</p>
<p>Returns <a href="option/enum.Option.html#variant.None"><code>None</code></a> if the pattern doesn't match.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines if
a character matches.</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;L√∂we ËÄÅËôé L√©opard&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&#39;√©&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&quot;L√©opard&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));</pre>
<p>More complex patterns using point-free style and closures:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;L√∂we ËÄÅËôé L√©opard&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">char</span>::<span class="ident">is_whitespace</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">char</span>::<span class="ident">is_lowercase</span>), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="op">|</span><span class="ident">c</span>: <span class="ident">char</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">is_whitespace</span>() <span class="op">||</span> <span class="ident">c</span>.<span class="ident">is_lowercase</span>()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="op">|</span><span class="ident">c</span>: <span class="ident">char</span><span class="op">|</span> (<span class="ident">c</span> <span class="op">&lt;</span> <span class="string">&#39;o&#39;</span>) <span class="op">&amp;&amp;</span> (<span class="ident">c</span> <span class="op">&gt;</span> <span class="string">&#39;a&#39;</span>)), <span class="prelude-val">Some</span>(<span class="number">4</span>));</pre>
<p>Not finding the pattern:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;L√∂we ËÄÅËôé L√©opard&quot;</span>;
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">x</span>), <span class="prelude-val">None</span>);</pre>
</div><h4 id='method.rfind' class="method"><span id='rfind.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.rfind' class='fnname'>rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2981-2985' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the byte index of the last character of this string slice that
matches the pattern.</p>
<p>Returns <a href="option/enum.Option.html#variant.None"><code>None</code></a> if the pattern doesn't match.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines if
a character matches.</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;L√∂we ËÄÅËôé L√©opard&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&#39;√©&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));</pre>
<p>More complex patterns with closures:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;L√∂we ËÄÅËôé L√©opard&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">char</span>::<span class="ident">is_whitespace</span>), <span class="prelude-val">Some</span>(<span class="number">12</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">char</span>::<span class="ident">is_lowercase</span>), <span class="prelude-val">Some</span>(<span class="number">20</span>));</pre>
<p>Not finding the pattern:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;L√∂we ËÄÅËôé L√©opard&quot;</span>;
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">x</span>), <span class="prelude-val">None</span>);</pre>
</div><h4 id='method.split' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Split.html" title="struct core::str::Split">Split</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Split.html" title="struct core::str::Split">Split</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Split.html" title="struct core::str::Split">Split</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><span id='split.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.split' class='fnname'>split</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Split.html" title="struct core::str::Split">Split</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3095-3103' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines the
split.</p>
<h1 id="iterator-behavior" class="section-header"><a href="#iterator-behavior">Iterator behavior</a></h1>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, eg, <a href="primitive.char.html"><code>char</code></a> but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="#method.rsplit"><code>rsplit</code></a> method can be used.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">split</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;lamb&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">split</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">split</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1def2ghi&quot;</span>.<span class="ident">split</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXtigerXleopard&quot;</span>.<span class="ident">split</span>(<span class="ident">char</span>::<span class="ident">is_uppercase</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);</pre>
<p>A more complex pattern, using a closure:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);</pre>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings in the output:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;||||a||b|c&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39;|&#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</pre>
<p>Contiguous separators are separated by the empty string.</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;(///)&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39;/&#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;(&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;)&quot;</span>]);</pre>
<p>Separators at the start or end of a string are neighbored
by empty strings.</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;010&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;0&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;&quot;</span>]);</pre>
<p>When the empty string is used as a separator, it separates
every character in the string, along with the beginning
and end of the string.</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">f</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;rust&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;&quot;</span>]);</pre>
<p>Contiguous separators can lead to possibly surprising behavior
when whitespace is used as the separator. This code is correct:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;    a  b c&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</pre>
<p>It does <em>not</em> give you:</p>

<div class='information'><div class='tooltip ignore'>‚ìò<span class='tooltiptext'>This example is not tested</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</pre>
<p>Use <a href="#method.split_whitespace"><code>split_whitespace</code></a> for this behavior.</p>
</div><h4 id='method.rsplit' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplit.html" title="struct core::str::RSplit">RSplit</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplit.html" title="struct core::str::RSplit">RSplit</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplit.html" title="struct core::str::RSplit">RSplit</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><span id='rsplit.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.rsplit' class='fnname'>rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplit.html" title="struct core::str::RSplit">RSplit</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3151-3155' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern and yielded in reverse order.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines the
split.</p>
<h1 id="iterator-behavior-1" class="section-header"><a href="#iterator-behavior-1">Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="#method.split"><code>split</code></a> method can be used.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;Mary&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;lion&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lion&quot;</span>]);</pre>
<p>A more complex pattern, using a closure:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;abc&quot;</span>]);</pre>
</div><h4 id='method.split_terminator' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitTerminator.html" title="struct core::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitTerminator.html" title="struct core::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitTerminator.html" title="struct core::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><span id='split_terminator.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.split_terminator' class='fnname'>split_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitTerminator.html" title="struct core::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3198-3203' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines the
split.</p>
<p>Equivalent to <a href="#method.split"><code>split</code></a>, except that the trailing substring
is skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h1 id="iterator-behavior-2" class="section-header"><a href="#iterator-behavior-2">Iterator behavior</a></h1>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, eg, <a href="primitive.char.html"><code>char</code></a> but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="#method.rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B.&quot;</span>.<span class="ident">split_terminator</span>(<span class="string">&#39;.&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A..B..&quot;</span>.<span class="ident">split_terminator</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>]);</pre>
</div><h4 id='method.rsplit_terminator' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplitTerminator.html" title="struct core::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplitTerminator.html" title="struct core::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplitTerminator.html" title="struct core::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><span id='rsplit_terminator.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.rsplit_terminator' class='fnname'>rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplitTerminator.html" title="struct core::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3245-3249' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>
<p>The pattern can be a simple <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that
determines the split.
Additional libraries might provide more complex patterns like
regular expressions.</p>
<p>Equivalent to <a href="#method.split"><code>split</code></a>, except that the trailing substring is
skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h1 id="iterator-behavior-3" class="section-header"><a href="#iterator-behavior-3">Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a
reverse search, and it will be double ended if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="#method.split_terminator"><code>split_terminator</code></a> method can be
used.</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B.&quot;</span>.<span class="ident">rsplit_terminator</span>(<span class="string">&#39;.&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A..B..&quot;</span>.<span class="ident">rsplit_terminator</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;A&quot;</span>]);</pre>
</div><h4 id='method.splitn' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitN.html" title="struct core::str::SplitN">SplitN</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitN.html" title="struct core::str::SplitN">SplitN</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitN.html" title="struct core::str::SplitN">SplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><span id='splitn.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.splitn' class='fnname'>splitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitN.html" title="struct core::str::SplitN">SplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3298-3303' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>An iterator over substrings of the given string slice, separated by a
pattern, restricted to returning at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines the
split.</p>
<h1 id="iterator-behavior-4" class="section-header"><a href="#iterator-behavior-4">Iterator behavior</a></h1>
<p>The returned iterator will not be double ended, because it is
not efficient to support.</p>
<p>If the pattern allows a reverse search, the <a href="#method.rsplitn"><code>rsplitn</code></a> method can be
used.</p>
<h1 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lambda&quot;</span>.<span class="ident">splitn</span>(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a little lambda&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">splitn</span>(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tigerXleopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXdef&quot;</span>.<span class="ident">splitn</span>(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abcXdef&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">splitn</span>(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);</pre>
<p>A more complex pattern, using a closure:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">splitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;defXghi&quot;</span>]);</pre>
</div><h4 id='method.rsplitn' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplitN.html" title="struct core::str::RSplitN">RSplitN</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplitN.html" title="struct core::str::RSplitN">RSplitN</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplitN.html" title="struct core::str::RSplitN">RSplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><span id='rsplitn.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.rsplitn' class='fnname'>rsplitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplitN.html" title="struct core::str::RSplitN">RSplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3349-3353' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>An iterator over substrings of this string slice, separated by a
pattern, starting from the end of the string, restricted to returning
at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that
determines the split.</p>
<h1 id="iterator-behavior-5" class="section-header"><a href="#iterator-behavior-5">Iterator behavior</a></h1>
<p>The returned iterator will not be double ended, because it is not
efficient to support.</p>
<p>For splitting from the front, the <a href="#method.splitn"><code>splitn</code></a> method can be used.</p>
<h1 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;Mary had a&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">3</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lionX&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;lion::tiger&quot;</span>]);</pre>
<p>A more complex pattern, using a closure:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;abc1def&quot;</span>]);</pre>
</div><h4 id='method.matches' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Matches.html" title="struct core::str::Matches">Matches</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Matches.html" title="struct core::str::Matches">Matches</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Matches.html" title="struct core::str::Matches">Matches</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><span id='matches.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.matches' class='fnname'>matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Matches.html" title="struct core::str::Matches">Matches</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.2.0'>1.2.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3390-3392' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>An iterator over the disjoint matches of a pattern within the given string
slice.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that
determines if a character matches.</p>
<h1 id="iterator-behavior-6" class="section-header"><a href="#iterator-behavior-6">Iterator behavior</a></h1>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, eg, <a href="primitive.char.html"><code>char</code></a> but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="#method.rmatches"><code>rmatches</code></a> method can be used.</p>
<h1 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">matches</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abc2abc3&quot;</span>.<span class="ident">matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]);</pre>
</div><h4 id='method.rmatches' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RMatches.html" title="struct core::str::RMatches">RMatches</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RMatches.html" title="struct core::str::RMatches">RMatches</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RMatches.html" title="struct core::str::RMatches">RMatches</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><span id='rmatches.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.rmatches' class='fnname'>rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RMatches.html" title="struct core::str::RMatches">RMatches</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.2.0'>1.2.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3427-3431' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>An iterator over the disjoint matches of a pattern within this string slice,
yielded in reverse order.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines if
a character matches.</p>
<h1 id="iterator-behavior-7" class="section-header"><a href="#iterator-behavior-7">Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="#method.matches"><code>matches</code></a> method can be used.</p>
<h1 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">rmatches</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abc2abc3&quot;</span>.<span class="ident">rmatches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>]);</pre>
</div><h4 id='method.match_indices' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.MatchIndices.html" title="struct core::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.MatchIndices.html" title="struct core::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.MatchIndices.html" title="struct core::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><span id='match_indices.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.match_indices' class='fnname'>match_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.MatchIndices.html" title="struct core::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.5.0'>1.5.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3473-3475' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>An iterator over the disjoint matches of a pattern within this string
slice as well as the index that the match starts at.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the first match are returned.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines
if a character matches.</p>
<h1 id="iterator-behavior-8" class="section-header"><a href="#iterator-behavior-8">Iterator behavior</a></h1>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, eg, <a href="primitive.char.html"><code>char</code></a> but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="#method.rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p>
<h1 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abcabc2&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;ababa&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;aba&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">0</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the first `aba`</span></pre>
</div><h4 id='method.rmatch_indices' class="method"><div class="important-traits"><div class='tooltip'>‚ìò<span class='tooltiptext'>Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RMatchIndices.html" title="struct core::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RMatchIndices.html" title="struct core::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html" title="trait core::iter::iterator::Iterator">Iterator</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RMatchIndices.html" title="struct core::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><span id='rmatch_indices.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.rmatch_indices' class='fnname'>rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RMatchIndices.html" title="struct core::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.5.0'>1.5.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3516-3520' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>An iterator over the disjoint matches of a pattern within <code>self</code>,
yielded in reverse order along with the index of the match.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the last match are returned.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines if a
character matches.</p>
<h1 id="iterator-behavior-9" class="section-header"><a href="#iterator-behavior-9">Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="#method.match_indices"><code>match_indices</code></a> method can be used.</p>
<h1 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abcabc2&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;ababa&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;aba&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">2</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the last `aba`</span></pre>
</div><h4 id='method.trim' class="method"><span id='trim.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.trim' class='fnname'>trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3537-3539' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a string slice with leading and trailing whitespace removed.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim</span>());</pre>
</div><h4 id='method.trim_left' class="method"><span id='trim_left.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.trim_left' class='fnname'>trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3573-3575' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a string slice with leading whitespace removed.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="text-directionality" class="section-header"><a href="#text-directionality">Text directionality</a></h1>
<p>A string is a sequence of bytes. 'Left' in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are 'right to left' rather than 'left to right', this will be
the <em>right</em> side, not the left.</p>
<h1 id="examples-31" class="section-header"><a href="#examples-31">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Hello\tworld\t&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_left</span>());</pre>
<p>Directionality:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  English&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;E&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_left</span>().<span class="ident">chars</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  ◊¢◊ë◊®◊ô◊™&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;◊¢&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_left</span>().<span class="ident">chars</span>().<span class="ident">next</span>());</pre>
</div><h4 id='method.trim_right' class="method"><span id='trim_right.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.trim_right' class='fnname'>trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3609-3611' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a string slice with trailing whitespace removed.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="text-directionality-1" class="section-header"><a href="#text-directionality-1">Text directionality</a></h1>
<p>A string is a sequence of bytes. 'Right' in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are 'right to left' rather than 'left to right', this will be
the <em>left</em> side, not the right.</p>
<h1 id="examples-32" class="section-header"><a href="#examples-32">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot; Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_right</span>());</pre>
<p>Directionality:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;English  &quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;h&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_right</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;◊¢◊ë◊®◊ô◊™  &quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;◊™&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_right</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());</pre>
</div><h4 id='method.trim_matches' class="method"><span id='trim_matches.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.trim_matches' class='fnname'>trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.DoubleEndedSearcher.html" title="trait core::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3639-3657' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a string slice with all prefixes and suffixes that match a
pattern repeatedly removed.</p>
<p>The pattern can be a <a href="primitive.char.html"><code>char</code></a> or a closure that determines if a
character matches.</p>
<h1 id="examples-33" class="section-header"><a href="#examples-33">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>), <span class="string">&quot;foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar&quot;</span>);</pre>
<p>A more complex pattern, using a closure:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;1foo1barXX&quot;</span>.<span class="ident">trim_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);</pre>
</div><h4 id='method.trim_left_matches' class="method"><span id='trim_left_matches.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.trim_left_matches' class='fnname'>trim_left_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3686-3696' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines if
a character matches.</p>
<h1 id="text-directionality-2" class="section-header"><a href="#text-directionality-2">Text directionality</a></h1>
<p>A string is a sequence of bytes. 'Left' in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are 'right to left' rather than 'left to right', this will be
the <em>right</em> side, not the left.</p>
<h1 id="examples-34" class="section-header"><a href="#examples-34">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar11&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>), <span class="string">&quot;foo1bar123&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar12&quot;</span>);</pre>
</div><h4 id='method.trim_right_matches' class="method"><span id='trim_right_matches.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.trim_right_matches' class='fnname'>trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3731-3743' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that
determines if a character matches.</p>
<h1 id="text-directionality-3" class="section-header"><a href="#text-directionality-3">Text directionality</a></h1>
<p>A string is a sequence of bytes. 'Right' in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are 'right to left' rather than 'left to right', this will be
the <em>left</em> side, not the right.</p>
<h1 id="examples-35" class="section-header"><a href="#examples-35">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;11foo1bar&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>), <span class="string">&quot;123foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="ident">x</span>), <span class="string">&quot;12foo1bar&quot;</span>);</pre>
<p>A more complex pattern, using a closure:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;1fooX&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;1foo&quot;</span>);</pre>
</div><h4 id='method.parse' class="method"><span id='parse.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.parse' class='fnname'>parse</a>&lt;F&gt;(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, &lt;F as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/trait.FromStr.html" title="trait core::str::FromStr">FromStr</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/str/trait.FromStr.html#associatedtype.Err" title="type core::str::FromStr::Err">Err</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/trait.FromStr.html" title="trait core::str::FromStr">FromStr</a>,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3791-3793' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Parses this string slice into another type.</p>
<p>Because <code>parse</code> is so general, it can cause problems with type
inference. As such, <code>parse</code> is one of the few times you'll see
the syntax affectionately known as the 'turbofish': <code>::&lt;&gt;</code>. This
helps the inference algorithm understand specifically which type
you're trying to parse into.</p>
<p><code>parse</code> can parse any type that implements the <a href="str/trait.FromStr.html"><code>FromStr</code></a> trait.</p>
<h1 id="errors" class="section-header"><a href="#errors">Errors</a></h1>
<p>Will return <a href="str/trait.FromStr.html#associatedtype.Err"><code>Err</code></a> if it's not possible to parse this string slice into
the desired type.</p>
<h1 id="examples-36" class="section-header"><a href="#examples-36">Examples</a></h1>
<p>Basic usage</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">four</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="string">&quot;4&quot;</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">4</span>, <span class="ident">four</span>);</pre>
<p>Using the 'turbofish' instead of annotating <code>four</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="string">&quot;4&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="ident">four</span>);</pre>
<p>Failing to parse:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">nope</span> <span class="op">=</span> <span class="string">&quot;j&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">nope</span>.<span class="ident">is_err</span>());</pre>
</div><h4 id='method.is_ascii' class="method"><span id='is_ascii.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.is_ascii' class='fnname'>is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.23.0'>1.23.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3808-3813' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Checks if all characters in this string are within the ASCII range.</p>
<h1 id="examples-37" class="section-header"><a href="#examples-37">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">ascii</span> <span class="op">=</span> <span class="string">&quot;hello!\n&quot;</span>;
<span class="kw">let</span> <span class="ident">non_ascii</span> <span class="op">=</span> <span class="string">&quot;Gr√º√üe, J√ºrgen ‚ù§&quot;</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">ascii</span>.<span class="ident">is_ascii</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">non_ascii</span>.<span class="ident">is_ascii</span>());</pre>
</div><h4 id='method.eq_ignore_ascii_case' class="method"><span id='eq_ignore_ascii_case.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.eq_ignore_ascii_case' class='fnname'>eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.23.0'>1.23.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3829-3831' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Checks that two strings are an ASCII case-insensitive match.</p>
<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,
but without allocating and copying temporaries.</p>
<h1 id="examples-38" class="section-header"><a href="#examples-38">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="string">&quot;Ferris&quot;</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="string">&quot;FERRIS&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="string">&quot;Ferr√∂s&quot;</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="string">&quot;FERR√∂S&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="string">&quot;Ferr√∂s&quot;</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="string">&quot;FERR√ñS&quot;</span>));</pre>
</div></div><div class='impl-items'><h4 id='method.replace' class="method"><span id='replace.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.replace' class='fnname'>replace</a>&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#265-275' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Replaces all matches of a pattern with another string.</p>
<p><code>replace</code> creates a new <a href="string/struct.String.html"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice.</p>
<h1 id="examples-39" class="section-header"><a href="#examples-39">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is old&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;this is new&quot;</span>, <span class="ident">s</span>.<span class="ident">replace</span>(<span class="string">&quot;old&quot;</span>, <span class="string">&quot;new&quot;</span>));</pre>
<p>When the pattern doesn't match:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is old&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">s</span>.<span class="ident">replace</span>(<span class="string">&quot;cookie monster&quot;</span>, <span class="string">&quot;little lamb&quot;</span>));</pre>
</div><h4 id='method.replacen' class="method"><span id='replacen.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.replacen' class='fnname'>replacen</a>&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, count: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.16.0'>1.16.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#305-316' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Replaces first N matches of a pattern with another string.</p>
<p><code>replacen</code> creates a new <a href="string/struct.String.html"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice at most <code>count</code> times.</p>
<h1 id="examples-40" class="section-header"><a href="#examples-40">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;foo foo 123 foo&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;new new 123 foo&quot;</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;new&quot;</span>, <span class="number">2</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;faa fao 123 foo&quot;</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="string">&#39;o&#39;</span>, <span class="string">&quot;a&quot;</span>, <span class="number">3</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;foo foo new23 foo&quot;</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>, <span class="string">&quot;new&quot;</span>, <span class="number">1</span>));</pre>
<p>When the pattern doesn't match:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is old&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="string">&quot;cookie monster&quot;</span>, <span class="string">&quot;little lamb&quot;</span>, <span class="number">10</span>));</pre>
</div><h4 id='method.to_lowercase' class="method"><span id='to_lowercase.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.to_lowercase' class='fnname'>to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.2.0'>1.2.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#360-392' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the lowercase equivalent of this string slice, as a new <a href="string/struct.String.html"><code>String</code></a>.</p>
<p>'Lowercase' is defined according to the terms of the Unicode Derived Core Property
<code>Lowercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="string/struct.String.html"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h1 id="examples-41" class="section-header"><a href="#examples-41">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;HELLO&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;hello&quot;</span>, <span class="ident">s</span>.<span class="ident">to_lowercase</span>());</pre>
<p>A tricky example, with sigma:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">sigma</span> <span class="op">=</span> <span class="string">&quot;Œ£&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;œÉ&quot;</span>, <span class="ident">sigma</span>.<span class="ident">to_lowercase</span>());

<span class="comment">// but at the end of a word, it&#39;s œÇ, not œÉ:</span>
<span class="kw">let</span> <span class="ident">odysseus</span> <span class="op">=</span> <span class="string">&quot;·ΩàŒîŒ•Œ£Œ£ŒïŒéŒ£&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;·ΩÄŒ¥œÖœÉœÉŒµœçœÇ&quot;</span>, <span class="ident">odysseus</span>.<span class="ident">to_lowercase</span>());</pre>
<p>Languages without case are not changed:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">new_year</span> <span class="op">=</span> <span class="string">&quot;ÂÜúÂéÜÊñ∞Âπ¥&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">new_year</span>, <span class="ident">new_year</span>.<span class="ident">to_lowercase</span>());</pre>
</div><h4 id='method.to_uppercase' class="method"><span id='to_uppercase.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.to_uppercase' class='fnname'>to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.2.0'>1.2.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#423-427' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the uppercase equivalent of this string slice, as a new <a href="string/struct.String.html"><code>String</code></a>.</p>
<p>'Uppercase' is defined according to the terms of the Unicode Derived Core Property
<code>Uppercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="string/struct.String.html"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h1 id="examples-42" class="section-header"><a href="#examples-42">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;hello&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;HELLO&quot;</span>, <span class="ident">s</span>.<span class="ident">to_uppercase</span>());</pre>
<p>Scripts without case are not changed:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">new_year</span> <span class="op">=</span> <span class="string">&quot;ÂÜúÂéÜÊñ∞Âπ¥&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">new_year</span>, <span class="ident">new_year</span>.<span class="ident">to_uppercase</span>());</pre>
</div><h4 id='method.escape_debug' class="method"><span id='escape_debug.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.escape_debug' class='fnname'>escape_debug</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#438-446' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='stability'><div class='stab unstable'><details><summary><span class=microscope>üî¨</span> This is a nightly-only experimental API.  (<code>str_escape</code>)</summary><p>return type may change to be an iterator</p>
</details></div></div><div class='docblock'><p>Escapes each char in <code>s</code> with <a href="primitive.char.html#method.escape_debug"><code>char::escape_debug</code></a>.</p>
<p>Note: only extended grapheme codepoints that begin the string will be
escaped.</p>
</div><h4 id='method.escape_default' class="method"><span id='escape_default.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.escape_default' class='fnname'>escape_default</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#454-456' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='stability'><div class='stab unstable'><details><summary><span class=microscope>üî¨</span> This is a nightly-only experimental API.  (<code>str_escape</code>)</summary><p>return type may change to be an iterator</p>
</details></div></div><div class='docblock'><p>Escapes each char in <code>s</code> with <a href="primitive.char.html#method.escape_default"><code>char::escape_default</code></a>.</p>
</div><h4 id='method.escape_unicode' class="method"><span id='escape_unicode.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.escape_unicode' class='fnname'>escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#464-466' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='stability'><div class='stab unstable'><details><summary><span class=microscope>üî¨</span> This is a nightly-only experimental API.  (<code>str_escape</code>)</summary><p>return type may change to be an iterator</p>
</details></div></div><div class='docblock'><p>Escapes each char in <code>s</code> with <a href="primitive.char.html#method.escape_unicode"><code>char::escape_unicode</code></a>.</p>
</div><h4 id='method.repeat' class="method"><span id='repeat.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.repeat' class='fnname'>repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.16.0'>1.16.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#502-504' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Create a <a href="string/struct.String.html"><code>String</code></a> by repeating a string <code>n</code> times.</p>
<h1 id="examples-43" class="section-header"><a href="#examples-43">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;abc&quot;</span>.<span class="ident">repeat</span>(<span class="number">4</span>), <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;abcabcabcabc&quot;</span>));</pre>
</div><h4 id='method.to_ascii_uppercase' class="method"><span id='to_ascii_uppercase.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.to_ascii_uppercase' class='fnname'>to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.23.0'>1.23.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#529-534' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a copy of this string where each character is mapped to its
ASCII upper case equivalent.</p>
<p>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',
but non-ASCII letters are unchanged.</p>
<p>To uppercase the value in-place, use <a href="#method.make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p>
<p>To uppercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_uppercase"><code>to_uppercase</code></a>.</p>
<h1 id="examples-44" class="section-header"><a href="#examples-44">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Gr√º√üe, J√ºrgen ‚ù§&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;GR√º√üE, J√ºRGEN ‚ù§&quot;</span>, <span class="ident">s</span>.<span class="ident">to_ascii_uppercase</span>());</pre>
</div><h4 id='method.to_ascii_lowercase' class="method"><span id='to_ascii_lowercase.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.to_ascii_lowercase' class='fnname'>to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.23.0'>1.23.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#559-564' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a copy of this string where each character is mapped to its
ASCII lower case equivalent.</p>
<p>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',
but non-ASCII letters are unchanged.</p>
<p>To lowercase the value in-place, use <a href="#method.make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p>
<p>To lowercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_lowercase"><code>to_lowercase</code></a>.</p>
<h1 id="examples-45" class="section-header"><a href="#examples-45">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Gr√º√üe, J√ºrgen ‚ù§&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;gr√º√üe, j√ºrgen ‚ù§&quot;</span>, <span class="ident">s</span>.<span class="ident">to_ascii_lowercase</span>());</pre>
</div></div>
                <h2 id='implementations' class='small-section-header'>
                  Trait Implementations<a href='#implementations' class='anchor'></a>
                </h2>
                <div id='implementations-list'><h3 id='impl-Clone' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../compact/struct.CString.html" title="struct compact::CString">CompactString</a></code><a href='#impl-Clone' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#6' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.clone' class="method"><span id='clone.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class="struct" href="../compact/struct.CString.html" title="struct compact::CString">CompactString</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#6' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class="method"><span id='clone_from.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/clone.rs.html#130-132' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id='impl-Default' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="../compact/struct.CString.html" title="struct compact::CString">CompactString</a></code><a href='#impl-Default' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#6' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.default' class="method"><span id='default.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default' class='fnname'>default</a>() -&gt; <a class="struct" href="../compact/struct.CString.html" title="struct compact::CString">CompactString</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#6' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><h3 id='impl-Deref' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="../compact/struct.CString.html" title="struct compact::CString">CompactString</a></code><a href='#impl-Deref' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#23-29' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='associatedtype.Target' class="type"><span id='Target.t' class='invisible'><code>type <a href='https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target' class="type">Target</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code></span></h4>
<div class='docblock'><p>The resulting type after dereferencing.</p>
</div><h4 id='method.deref' class="method"><span id='deref.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#tymethod.deref' class='fnname'>deref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#26-28' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Dereferences the value.</p>
</div></div><h3 id='impl-From%3CString%3E' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt; for <a class="struct" href="../compact/struct.CString.html" title="struct compact::CString">CompactString</a></code><a href='#impl-From%3CString%3E' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#31-37' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.from' class="method"><span id='from.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(string: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) -&gt; <a class="struct" href="../compact/struct.CString.html" title="struct compact::CString">CompactString</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#32-36' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Compact' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="../compact/trait.Compact.html" title="trait compact::Compact">Compact</a> for <a class="struct" href="../compact/struct.CString.html" title="struct compact::CString">CompactString</a></code><a href='#impl-Compact' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#39-57' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.is_still_compact' class="method"><span id='is_still_compact.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='../compact/trait.Compact.html#tymethod.is_still_compact' class='fnname'>is_still_compact</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#40-42' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Is the object's dynamic part stored compactly?</p>
</div><h4 id='method.dynamic_size_bytes' class="method"><span id='dynamic_size_bytes.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='../compact/trait.Compact.html#tymethod.dynamic_size_bytes' class='fnname'>dynamic_size_bytes</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#44-46' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Size of the dynamic part in bytes</p>
</div><h4 id='method.compact' class="method"><span id='compact.v' class='invisible'><table class='table-display'><tbody><tr><td><code>unsafe fn <a href='../compact/trait.Compact.html#tymethod.compact' class='fnname'>compact</a>(source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut Self</a>, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut Self</a>, new_dynamic_part: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#48-50' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Copy the static part of <code>source</code> to <code>dest</code> and compactly store the dynamic part of <code>source</code> as the new dynamic part of <code>dest</code> at <code>new_dynamic_part</code>. This semantically moves source into dest. <a href="../compact/trait.Compact.html#tymethod.compact">Read more</a></p>
</div><h4 id='method.decompact' class="method"><span id='decompact.v' class='invisible'><table class='table-display'><tbody><tr><td><code>unsafe fn <a href='../compact/trait.Compact.html#tymethod.decompact' class='fnname'>decompact</a>(source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const Self</a>) -&gt; Self</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact_str.rs.html#52-56' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Creates a clone of self with the dynamic part guaranteed to be stored freely. <a href="../compact/trait.Compact.html#tymethod.decompact">Read more</a></p>
</div><h4 id='method.total_size_bytes' class="method"><span id='total_size_bytes.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='../compact/trait.Compact.html#method.total_size_bytes' class='fnname'>total_size_bytes</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact.rs.html#13-15' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Total size of the object (static part + dynamic part)</p>
</div><h4 id='method.behind' class="method"><span id='behind.v' class='invisible'><table class='table-display'><tbody><tr><td><code>unsafe fn <a href='../compact/trait.Compact.html#method.behind' class='fnname'>behind</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut Self</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact.rs.html#23-25' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Get a pointer to behind the static part of <code>self</code> (commonly used place for the dynamic part)</p>
</div><h4 id='method.compact_behind' class="method"><span id='compact_behind.v' class='invisible'><table class='table-display'><tbody><tr><td><code>unsafe fn <a href='../compact/trait.Compact.html#method.compact_behind' class='fnname'>compact_behind</a>(source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut Self</a>, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut Self</a>)</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/compact/compact.rs.html#28-31' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Like <code>compact</code> with <code>new_dynamic_part</code> set to <code>dest.behind()</code></p>
</div></div></div>
                <h2 id='synthetic-implementations' class='small-section-header'>
                  Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a>
                </h2>
                <div id='synthetic-implementations-list'>
            <h3 id='impl-Send' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../compact/struct.CString.html" title="struct compact::CString">CString</a></code><a href='#impl-Send' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../compact/struct.CString.html" title="struct compact::CString">CString</a></code><a href='#impl-Sync' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>‚Üë</kbd></dt><dd>Move up in search results</dd><dt><kbd>‚Üì</kbd></dt><dd>Move down in search results</dd><dt><kbd>‚Üπ</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "compact";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>